// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: news.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getArticleByGUID = `-- name: GetArticleByGUID :one
SELECT feed_id, title, description, content, link, guid, author, published_at 
FROM feed_items 
WHERE guid = $1
`

type GetArticleByGUIDRow struct {
	FeedID      sql.NullInt32  `json:"feed_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Content     sql.NullString `json:"content"`
	Link        string         `json:"link"`
	Guid        string         `json:"guid"`
	Author      sql.NullString `json:"author"`
	PublishedAt sql.NullTime   `json:"published_at"`
}

// 根据 guid 来应该更好一点， 因为guid是唯一的， 而id不是
func (q *Queries) GetArticleByGUID(ctx context.Context, guid string) (GetArticleByGUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByGUID, guid)
	var i GetArticleByGUIDRow
	err := row.Scan(
		&i.FeedID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Link,
		&i.Guid,
		&i.Author,
		&i.PublishedAt,
	)
	return i, err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT feed_id, title, description, content, link, guid, author, published_at 
FROM feed_items 
WHERE id = $1
`

type GetArticleByIDRow struct {
	FeedID      sql.NullInt32  `json:"feed_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Content     sql.NullString `json:"content"`
	Link        string         `json:"link"`
	Guid        string         `json:"guid"`
	Author      sql.NullString `json:"author"`
	PublishedAt sql.NullTime   `json:"published_at"`
}

// 获取文章的详细信息， 这里需要根据文章的id来获取
func (q *Queries) GetArticleByID(ctx context.Context, id int32) (GetArticleByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.FeedID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Link,
		&i.Guid,
		&i.Author,
		&i.PublishedAt,
	)
	return i, err
}

const getArticlesByGUID = `-- name: GetArticlesByGUID :many
SELECT id, title, description, content, link, guid, author, published_at 
FROM feed_items 
WHERE guid = ANY($1::text[])
ORDER BY published_at DESC
`

type GetArticlesByGUIDRow struct {
	ID          int32          `json:"id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Content     sql.NullString `json:"content"`
	Link        string         `json:"link"`
	Guid        string         `json:"guid"`
	Author      sql.NullString `json:"author"`
	PublishedAt sql.NullTime   `json:"published_at"`
}

func (q *Queries) GetArticlesByGUID(ctx context.Context, dollar_1 []string) ([]GetArticlesByGUIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticlesByGUID, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticlesByGUIDRow
	for rows.Next() {
		var i GetArticlesByGUIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Link,
			&i.Guid,
			&i.Author,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewArticles = `-- name: GetNewArticles :many
SELECT id, feed_id, title, description, content, link, guid, author, keywords, published_at, created_at FROM feed_items
WHERE published_at > $1  -- 这里每天根据推荐时间选取
ORDER BY published_at DESC
LIMIT $2
`

type GetNewArticlesParams struct {
	PublishedAt sql.NullTime `json:"published_at"`
	Limit       int32        `json:"limit"`
}

// 获取新的文章， 这里需要根据推荐算法，所以这里筛选出来的接口还应该需要接到推荐算法上
func (q *Queries) GetNewArticles(ctx context.Context, arg GetNewArticlesParams) ([]FeedItem, error) {
	rows, err := q.db.QueryContext(ctx, getNewArticles, arg.PublishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedItem
	for rows.Next() {
		var i FeedItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Link,
			&i.Guid,
			&i.Author,
			pq.Array(&i.Keywords),
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomArticles = `-- name: GetRandomArticles :many
SELECT id, feed_id, title, description, content, link, guid, author, keywords, published_at, created_at FROM feed_items
WHERE published_at > $1  -- 最近一段时间的新闻
ORDER BY RANDOM()
LIMIT $2
`

type GetRandomArticlesParams struct {
	PublishedAt sql.NullTime `json:"published_at"`
	Limit       int32        `json:"limit"`
}

// 随机获取新闻文章
func (q *Queries) GetRandomArticles(ctx context.Context, arg GetRandomArticlesParams) ([]FeedItem, error) {
	rows, err := q.db.QueryContext(ctx, getRandomArticles, arg.PublishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FeedItem
	for rows.Next() {
		var i FeedItem
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Link,
			&i.Guid,
			&i.Author,
			pq.Array(&i.Keywords),
			&i.PublishedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
