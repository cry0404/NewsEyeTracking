// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: code.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getABTestConfigByInviteCodeID = `-- name: GetABTestConfigByInviteCodeID :one
SELECT has_recommend, has_more_information 
FROM invite_codes 
WHERE id = $1
`

type GetABTestConfigByInviteCodeIDRow struct {
	HasRecommend       sql.NullBool `json:"has_recommend"`
	HasMoreInformation sql.NullBool `json:"has_more_information"`
}

// 根据邀请码ID获取A/B测试配置，但是这里也许该再解耦一下，毕竟 has_more infomation 应该是只需要查询一次的，没必要一直查询
func (q *Queries) GetABTestConfigByInviteCodeID(ctx context.Context, id uuid.UUID) (GetABTestConfigByInviteCodeIDRow, error) {
	row := q.db.QueryRowContext(ctx, getABTestConfigByInviteCodeID, id)
	var i GetABTestConfigByInviteCodeIDRow
	err := row.Scan(&i.HasRecommend, &i.HasMoreInformation)
	return i, err
}

const getIdAndEmailByCode = `-- name: GetIdAndEmailByCode :one
SELECT id,email FROM invite_codes WHERE code = $1
`

type GetIdAndEmailByCodeRow struct {
	ID    uuid.UUID `json:"id"`
	Email string    `json:"email"`
}

// 获取邀请码ID 和 email（注册时使用）
func (q *Queries) GetIdAndEmailByCode(ctx context.Context, code string) (GetIdAndEmailByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getIdAndEmailByCode, code)
	var i GetIdAndEmailByCodeRow
	err := row.Scan(&i.ID, &i.Email)
	return i, err
}

const markInviteCodeAsUsed = `-- name: MarkInviteCodeAsUsed :one
UPDATE invite_codes 
SET is_used = TRUE 
WHERE code = $1 
RETURNING id, code, is_used, has_recommend, has_more_information, created_at
`

type MarkInviteCodeAsUsedRow struct {
	ID                 uuid.UUID    `json:"id"`
	Code               string       `json:"code"`
	IsUsed             sql.NullBool `json:"is_used"`
	HasRecommend       sql.NullBool `json:"has_recommend"`
	HasMoreInformation sql.NullBool `json:"has_more_information"`
	CreatedAt          sql.NullTime `json:"created_at"`
}

// 标记邀请码为已使用, 这里在注册完后做标记即可
func (q *Queries) MarkInviteCodeAsUsed(ctx context.Context, code string) (MarkInviteCodeAsUsedRow, error) {
	row := q.db.QueryRowContext(ctx, markInviteCodeAsUsed, code)
	var i MarkInviteCodeAsUsedRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.IsUsed,
		&i.HasRecommend,
		&i.HasMoreInformation,
		&i.CreatedAt,
	)
	return i, err
}

const validateInviteCode = `-- name: ValidateInviteCode :one
SELECT id, code, is_used, has_recommend, has_more_information, created_at 
FROM invite_codes 
WHERE code = $1 AND (is_used IS NULL OR is_used = FALSE)
`

type ValidateInviteCodeRow struct {
	ID                 uuid.UUID    `json:"id"`
	Code               string       `json:"code"`
	IsUsed             sql.NullBool `json:"is_used"`
	HasRecommend       sql.NullBool `json:"has_recommend"`
	HasMoreInformation sql.NullBool `json:"has_more_information"`
	CreatedAt          sql.NullTime `json:"created_at"`
}

// 验证邀请码（检查是否存在且未使用）
func (q *Queries) ValidateInviteCode(ctx context.Context, code string) (ValidateInviteCodeRow, error) {
	row := q.db.QueryRowContext(ctx, validateInviteCode, code)
	var i ValidateInviteCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.IsUsed,
		&i.HasRecommend,
		&i.HasMoreInformation,
		&i.CreatedAt,
	)
	return i, err
}
